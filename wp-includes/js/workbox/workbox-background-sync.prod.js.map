{"version":3,"names":[],"mappings":"","sources":["packages/workbox-background-sync/browser.mjs"],"sourcesContent":["this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e,s){\"use strict\";try{self.workbox.v[\"workbox:background-sync:4.0.0-beta.0\"]=1}catch(t){}const i=2,n=\"workbox-background-sync\",r=\"requests\",a=\"queueName\",c=\"workbox-background-sync\",h=10080;class o{constructor(e){this.t=e,this.e=new t.DBWrapper(n,i,{onupgradeneeded:t=>this.s(t)})}async pushEntry(t){delete t.id,t.queueName=this.t,await this.e.add(r,t)}async unshiftEntry(t){const e=await this.e.get(r);e?t.id=e.id-1:delete t.id,t.queueName=this.t,await this.e.add(r,t)}async popEntry(){return this.i({direction:\"prev\"})}async shiftEntry(){return this.i({direction:\"next\"})}async i({direction:t}){const[e]=await this.e.getAllMatching(r,{direction:t,index:a,query:IDBKeyRange.only(this.t),count:1});if(e)return await this.e.delete(r,e.id),delete e.id,delete e.queueName,e}s(t){const s=t.target.result,i=t.target.transaction;let n=[];e.migrateDb(t,{v1:t=>{if(s.objectStoreNames.contains(r)){i.objectStore(r).openCursor().onsuccess=(({target:e})=>{const i=e.result;i?(n.push(i.value),i.continue()):(s.deleteObjectStore(r),t())})}else t()},v2:t=>{const e=s.createObjectStore(r,{autoIncrement:!0,keyPath:\"id\"});if(e.createIndex(a,a,{unique:!1}),n.length)for(const t of n){const{queueName:s,storableRequest:i}=t,n=i.timestamp,r=Object.assign(i.requestInit,{url:i.url});e.add({queueName:s,timestamp:n,requestData:r})}t()}})}}const u=[\"method\",\"referrer\",\"referrerPolicy\",\"mode\",\"credentials\",\"cache\",\"redirect\",\"integrity\",\"keepalive\"];class y{static async fromRequest(t){const e={url:t.url,headers:{}};\"GET\"!==t.method&&(e.body=await t.clone().blob());for(const[s,i]of t.headers.entries())e.headers[s]=i;for(const s of u)void 0!==t[s]&&(e[s]=t[s]);return new y(e)}constructor(t){this.n=t}toObject(){const t=Object.assign({},this.n);return t.headers=Object.assign({},this.n.headers),t.body&&(t.body=t.body.slice()),t}toRequest(){return new Request(this.n.url,this.n)}clone(){return new y(this.toObject())}}const w=new Set;class d{constructor(t,{onSync:e,maxRetentionTime:i}={}){if(w.has(t))throw new s.WorkboxError(\"duplicate-queue-name\",{name:t});w.add(t),this.r=t,this.a=e||this.replayRequests,this.c=i||h,this.h=new o(this.r),this.o()}get name(){return this.r}async pushRequest(t){await this.u(t,\"push\")}async unshiftRequest(t){await this.u(t,\"unshift\")}async popRequest(){return this.y(\"pop\")}async shiftRequest(){return this.y(\"shift\")}async u({request:t,metadata:e,timestamp:s=Date.now()},i){const n={requestData:(await y.fromRequest(t.clone())).toObject(),timestamp:s};e&&(n.metadata=e),await this.h[`${i}Entry`](n),await this.registerSync()}async y(t){const e=Date.now(),s=await this.h[`${t}Entry`]();if(s){const i=60*this.c*1e3;return e-s.timestamp>i?this.y(t):(s.request=new y(s.requestData).toRequest(),delete s.requestData,s)}}async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request)}catch(e){throw await this.unshiftRequest(t),new s.WorkboxError(\"queue-replay-failed\",{name:this.r})}}async registerSync(){if(\"sync\"in registration)try{await registration.sync.register(`${c}:${this.r}`)}catch(t){}}o(){\"sync\"in registration?self.addEventListener(\"sync\",t=>{t.tag===`${c}:${this.r}`&&t.waitUntil(this.a({queue:this}))}):this.a({queue:this})}static get w(){return w}}return Object.freeze({Queue:d,Plugin:class{constructor(...t){this.d=new d(...t),this.fetchDidFail=this.fetchDidFail.bind(this)}async fetchDidFail({request:t}){await this.d.pushRequest({request:t})}}})}(workbox.core._private,workbox.core._private,workbox.core._private);\n"],"file":"workbox-background-sync.prod.js"}